<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper
PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
"http://mybatis.org/dtd/mybatis-3-mapper.dtd">

<!-- #{id}表示等待传入的参数，parameterType表示参数类型，
resultType表示输出类型。 -->
<mapper namespace="cn.me.mapper.UserMapper">

	<select id="findUserById" parameterType="int" resultType="user">
		select * from user where id=#{id}
	</select>
	
	<!-- 直接用Map接收数据，key是user的属性名，value是属性值，这样没有User类也能查询  -->
	<select id="findUserById1" parameterType="int" resultType="map">
		select * from user where id=#{id}
	</select>
	
	<!-- List<User> l = s.selectList("findUserByName1", "%小%"); -->
	<select id="findUserByName1" parameterType="string" resultType="user">
		select * from user where username like #{aaa}
	</select>
	
	<!-- List<User> l = s.selectList("findUserByName2", "小"); -->
	<select id="findUserByName2" parameterType="string" resultType="user">
		select * from user where username like '%${value}%'
	</select>
	
	
	<!-- QueryVo封装了user，设置get/set方法，使用queryVo.user.username进行查询。 -->	
	<select id="findUserByQueryVo" parameterType="queryVo" 	resultType="user">
		select * from user where username like '%${user.username}%' 
			and sex=#{user.sex} and address like '%${user.address}%'
	</select>
	

	<insert id="insertUser" parameterType="user">
		<!-- last_insert_id()返回当前事务最后产生的id,这里id是自增所以resultType是int,
		keyProperty表示该值放到pojo的哪个属性上,order只有BEFORE和AFTER两个值,
		分别表示insert语句完成前/后获取值,这样设置新建user并保存后打印可以看见id而不用去数据库查 -->
		<selectKey resultType="int" keyProperty="id" order="AFTER">
			select last_insert_id()
		</selectKey>
		insert user(username,birthday,sex,address) 
			value(#{username},#{birthday},#{sex},#{address})			
	</insert>
	
	<!-- 如果是个包装类，比如role里有user，要获取user的id可以写#{role.user.id} -->
	<update id="updateUser" parameterType="user">
		update user set username=#{username},
			birthday=#{birthday},sex=#{sex},address=#{address} where id=#{id}			
	</update>
	
	<delete id="deleteUser" parameterType="int">
		delete from user where id=#{id}
	</delete>
	

	<!-- user有username,sex等5个属性，和数据库的表的字段一样，现在修改是挂号信成username1,sex1，
	直接使用上面的 findUserById方法不会报错，但是获取不到这两个属性的值。解决方法如下，
	设置resultMap，type是user的别名或全名，下面的column表示表里的名字，property是类的属性名，
	column和property一样的可以不写，然后方法不用resultType用resultMap。这个东西很常用 -->
	<resultMap id="user1" type="user">
		<id column="id" property="id"/>
		<result column="username" property="username1"/>
		<result column="sex" property="sex1"/>
		<result column="birthday" property="birthday"/>
		<result column="address" property="address"/>
	</resultMap>
	<select id="findUserById2" parameterType="int" 	resultMap="user1">
		select * from user where id=#{id}
	</select>


	<!-- where,if和foreach的用法，where可以自动处理第一个and，foreach可以拼接in查询 -->
	<select id="findUserList" parameterType="user" resultType="user">
		select * from user 
		<where>
			<if test="id!=null and id!=''">
				and id=#{id}
			</if>
			<if test="username!=null and username!=''">
				and username like '%${username}%'
			</if>
			<if test="ids!=null and ids.size>0">
	    		<foreach collection="ids" open=" and id in(" close=")" item="id" separator="," >
	    			#{id}
	    		</foreach>
			</if>
		</where>
	</select>
	
	<!-- Sql片段:将重复的sql提取出来，使用时用include引用，达到sql重用的目的 -->
	<sql id="query_user_where">
		<if test="id!=null and id!=''">
			and id=#{id}
		</if>
		<if test="username!=null and username!=''">
			and username like '%${username}%'
		</if>
	</sql>
	<select id="findUserList1" parameterType="user" resultType="user">
		select * from user 
		<where>
		<include refid="query_user_where"/>
		</where>
	</select>
	<!--  注意：如果引用其它mapper.xml的sql片段，则在引用时需要加上namespace，如下：
	<include refid="namespace.sql片段”/>-->
	
	
	<!-- set标签会去掉最后的逗号,实现部分更新 -->
	<update id="updateUser_if_set" parameterType="user">
		update user
		<set>
			<if test="name != null and name.length()>0">name = #{name},</if>
			<if test="gender != null and gender.length()>0">gender = #{gender},</if>
　　　　</set>
　　　　where id = #{id}
　　</update>

</mapper>