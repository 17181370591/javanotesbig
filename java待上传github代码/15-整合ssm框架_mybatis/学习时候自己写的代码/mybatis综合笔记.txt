mybatis生成的sql语句，parameterType="string"和#{}搭配会自动生成引号包裹，如果写'%#{value}%'传参数a会变成'%'a'%'报错，必须使用'%${value}%'，这里value不能改，
模糊查询一般用select * from user where username like '%${value}%'。用#{}的方法见UserMapper.xml的findUserByName1方法。

==================================================================

不同的mapper.xml可能方法id冲突，每个文件上面有个namespace，使用这个可以避免。
如下代码，指定selectOne使用test1的findUserById。
	@Override
	public User findById(int id) {
		SqlSession sqlSession = sqlSessionFactory.openSession();
		 User user = sqlSession.selectOne("test1.findUserById", id);
		 sqlSession.close();
		 return user;
	}

==================================================================	

满足条件4，5命名的情况下，下面代码可以实现包里的类名自动产生别名，pojo类似domain。
	 <typeAliases>
 		<package name="cn.itcast.mybatis.pojo"/>
		<!-- <typeAlias type="cn.itcast.mybatis.po.User" alias="user"/> -->
	</typeAliases> 
	
下面代码可以实现不用手动到各个pojo类xml文件，mapper类似service。
	<mappers>
		<package name="cn.itcast.mybatis.mapper"/>		
		<!-- <mapper resource="user.xml"></mapper> -->
		<!-- <mapper resource="mapper/userMapper.xml"></mapper> -->
		<!-- <mapper class="cn.itcast.mybatis.mapper.userMapper"></mapper> -->
	</mappers>
扫描mapper包用来建立 mapper接口和xml的一一对应关系并用xml的对应语句实现该接口方法，
扫描pojo包用获取各个 pojo类的别名。

==================================================================

count方法：
	<select id="findCount"  resultType="_int">
		select count(*) from user
	</select>
	
==================================================================

在mybatis的配置文件sqlMapConfig.xml里加上下面代码可以打印sql语句，非常方便。
<configuration>
	<settings>
		<setting name="logImpl" value="STDOUT_LOGGING"/>
	</settings>
</configuration>	
	
==================================================================

1对多和1对1	(详情见mybatis教案-day02的10到17页)：
这里1对1和1对多是从一个表来看的，比如1个user对应多个order，处理user时是1对多，处理order时是1对1(1个order只有1个user)，所以前面学的多对多在这里就是对双方的1对多。
1对1有两种方法：
方法1是用order1继承order，再加上user的一些属性，作为resultType，跨表查询的数据会自动填充进order1,；
方法2是resultMap，order里user的引用myuser，返回类型用自定义的resultMap，配置如下
	<resultMap type="Orders" id="orderUserResultMap">
		<!-- 一对一关联映射 -->
		<!-- 		property:Orders对象的user属性
		javaType：user属性对应 的类型		 -->
		<association property="user" javaType="cn.itcast.po.User">
			<!-- column:user表的主键对应的列  property：user对象中id属性-->
			<id column="user_id" property="id"/>
			<result column="username" property="username"/>
			<result column="address" property="address"/>
		</association>
	</resultMap>
	
多对多配置如下：
	<resultMap type="user" id="userOrderResultMap">
		<!-- 一对多关联映射 -->
		<collection property="orders" ofType="orders">
			<id property="id" column="oid"/>	
		      <!--用户id已经在user对象中存在，此处可以不设置-->
			<result property="userId" column="id"/> 
			<result property="number" column="number"/>
			<result property="createtime" column="createtime"/>
			<result property="note" column="note"/>
		</collection>
	</resultMap>
	
==================================================================

逆序工程，作用是生成mapper接口,对应的xml文件,POJO类和example类：
mapper接口里selective(选择性)表示非空才注入，即使用了if标签判断是否为空，空就不注入。
不会处理外键,1对1和1对多的关系。
example类的用法类似hibernate的criteria：
	UserExample example=new UserExample();
	example.createCriteria().addSexEqualTo(0).addNameLike("小");
	List<User> list=userMapper.selectByExample(example);

==================================================================

排序：
	UserExample example = new UserExample();
	Criteria criteria = example.createCriteria();
	criteria.andNameEqualTo("joe");
	criteria.andIdIsNull();
	example.setOrderByClause("name asc,email desc");
	List<?>list = Mapper.selectByExample(example);
相当于：
select * from user where name = 'joe' and id is null order by name asc,email desc

==================================================================

一、在 SQL 映射文件的 select 标签中添加 useGeneratedKeys="true" 属性与 keyProperty=" " 属性，keyProperty 的值表示的是将获取到的自增主键值赋给 JavaBean 中的某个字段。

    <!-- 
        useGeneratedKeys 设置为 true
        keyProperty 表示把获得的自增主键的值赋给 javabean 中的哪个属性，
        这里表示赋值给 employee 的 id 属性
    -->
    <insert id="addEmp" parameterType="employee" 
            useGeneratedKeys="true" keyProperty="id">
        insert into t_employee(username, gender, email) values (#{username}, #{gender}, #{email})
    </insert>

二、 测试，通过 javabean 的get()方法即可获得自增主键的值。

    @Test
    public void addEmpTest() throws IOException {
        // MyBatis 全局配置文件的路径
        String resource = "mybatis-config.xml";
        InputStream is = Resources.getResourceAsStream(resource);

        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(is);
        // 注意在这里设置为自动提交数据
        SqlSession sqlSession = sqlSessionFactory.openSession(true);
        EmployeeMapper employeeMapper = sqlSession.getMapper(EmployeeMapper.class);
        Employee employee = new Employee(null, "Jas", '1', "gdfg@foxmail.com");

        employeeMapper.addEmp(employee);

        System.out.println(employee.getId());
    }    

==================================================================

insertSelective和insert的区别：
insert会把对象的null项也插入，导致数据库设置默认值的项会出现null。
比如user有个字段createTime是DATETIME属性，默认值是CURRENT_TIMESTAMP，
插入新数据时不设置此属性，用insert表里是null，insertSelective是当前时间。

==================================================================

自己写的分页：

	<!-- mapper.xml部分 -->
		<!-- BaseResultMap部分 -->
		<resultMap id="BaseResultMap" type="cn.slq.pojo.Article" >
			<id column="id" property="id" jdbcType="INTEGER" />
			<result column="userid" property="userid" jdbcType="INTEGER" />
			..........................
		</resultMap>

		<select id="selectByPage" parameterType="map" resultMap="BaseResultMap">
			select * from article where forumid=#{forumid} 
				order by createtime desc limit #{currIndex} , #{pageSize}
		</select>

	<!-- serviceimpl.xml部分 -->
		public List<Article> findPage(Integer page, Integer rows, int fid) {
			Map data = new HashMap();
			data.put("forumid", fid);
			data.put("currIndex", page);
			data.put("pageSize", rows);
			List<Article> list = articleMapper.selectByPage(data);
			return list;
		}
	
==================================================================