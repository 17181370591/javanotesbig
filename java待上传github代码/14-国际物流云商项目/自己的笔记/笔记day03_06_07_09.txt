https://blog.csdn.net/superyxw/article/details/79942919
@orderby注解：
解决一对多和多对多的排序；

https://blog.csdn.net/qq_527235890/article/details/70196396
@MappedSuperclass：
要(domain层的)子类继承父类的注解，需要在父类上加上这个；
使用环境：
1.@MappedSuperclass注解使用在父类上面，是用来标识父类的
2.@MappedSuperclass标识的类表示其不能映射到数据库表，因为其不是一个完整的实体类，但是它所拥有的属性能够隐射在其子类对用的数据库表中
3.@MappedSuperclass标识得嘞不能再有@Entity或@Table注解



@DynamicInsert
@DynamicUpdate
这两个注解在一定程度上可以增加与数据库操作相关的速度，可以节省SQL语句的执行时间，提高程序的运行效率。

day06笔记：
userserviceimpl里，给新注册用户发送邮件，这里要接收错误而不是抛出，
(报错原因是因为邮件发送的问题而不是用户的问题)
因为抛出的话会回滚事务造成用户注册信息不被保存。

day07笔记：
数据库设计的3大范式：
1_每列不可拆分：
	比如地址是北京市朝阳区xx路，应该拆分成3列，省市：北京，区：xx，路：xx。
2_一个表只做一件事：
	比如学生信息表，不用来存储学生的各科考试成绩，应该重建一个成绩表。
3_消除表的传递依赖：
	数据不能存在传递关系，即每个属性都跟主键有直接关系而不是间接关系。
	像：a-->b-->c  属性之间含有这样的关系，是不符合第三范式的。

	比如Student表（学号，姓名，年龄，性别，所在院校，院校地址，院校电话）
	这样一个表结构，就存在上述关系。 学号--> 所在院校 --> (院校地址，院校电话)
	这样的表结构，我们应该拆开来，如下。
	（学号，姓名，年龄，性别，所在院校）--（所在院校，院校地址，院校电话）


三大范式只是一般设计数据库的基本理念，可以建立冗余较小、结构合理的数据库。
如果有特殊情况，当然要特殊对待，数据库设计最重要的是看需求跟性能，需求>性能>表结构。
所以不能一味的去追求范式建立数据库。


根据外键的id获取list的写法，教程用第二种，自己测试第一种也没问题，推荐第二种
	Specification<ContractProduct> spec = new Specification<ContractProduct>() {
		@Override
		public Predicate toPredicate(Root<ContractProduct> root, CriteriaQuery<?> query, CriteriaBuilder cb) {
			return cb.equal(root.get("contract").as(Contract.class),d.getContract());
			//return  cb.equal(root.get("contract").get("id").as(String.class),d.getContract().getId());
		}
	};
		
		
		

day09笔记：
报运单a和购销合同(contract简称c)是一对多的关系，因为一个a有多个c，且a里的合同一定在c里，
但是不能设置在数据库设置一对多的关系。因为如果设置一对多，删除a时会删除a的c，
但显然c不应该被a删除(c只应该在c自己的模块被删除，这里类似洋酒品类有多个品牌，现在需要删除洋酒品类统一归入酒品类，应该只删除品类而不应该删除下属的所有品牌)。
可以使用打断设计，即a里有一个字段保存c的id的集合，例如c1,c2.....

外面有 数据搬家 和 多方维护外键 的代码。
