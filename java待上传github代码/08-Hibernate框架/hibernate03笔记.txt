					hibernate框架_03



今日内容:
	  1 hibernate的一对多关系映射 
 
	  2 hibernate的多对多关系映射
	




回顾:
	表数据和表数据之间可以存在的关系?

		 一对多(最多)
			分类和商品
			
			crm: 客户表(customer)  联系人表(linkman)
			
			百度     百度客服1
				 百度客服2
				 百度客服3
				 百度客服4

		一对多的建表原则: 在多的一方创建一个字段当成是外键
				  然后让这个外键指向一的一方的主键

			

		
		 多对多
			学生和课程

			crm: 用户(User)和角色(role)


			jack		    员工
			rose		    班主任
					    助教

			N:N

		多对多的建表原则:
		在外部创建一张中间表 这个中间表中至少需要2个字段 分别指向各自表的主键

		ps: 以上的表创建和表数据之间的关系建立目前只需要明白
		    企业开发这些任务是项目经理的
		 
		 
		
		 
		 一对一(企业开发中很少 可以合成一张表来使用)
			
			公司对地址
		




hibernate是操作实体类:
		
		问题: 如何让实体类之间明白它们之间的关系?
		     
		      Customer类      LinkMan类

		     如果是1对多的关系?
			
			需要在一的一方有多的一方的集合
					在customer类中有linkMan的集合

			需求: 查客户以及客户下面所有的联系人?
					customer: 拿到了客户数据
						  拿到了联系人数据
			
			需要在多的一方有一的一方的对象
					 在LinkMan类中有Customer类的对象

			需求: 查联系人以及联系人所有的客户名字叫什么?
					LinkMan: 拿到了联系人的数据
						  拿到了客户的数据


		     
		      
		      User类		Role类
		      
		      如果是多对多?
			   在user类中有role类的集合
			   在role类中有User类的集合
			   在双方中都有对方的集合


			

		     夫类		妻类

		     如果是一对一?
			    在夫类中有妻类的对象
		            在妻类中有夫类的对象
			    在双方中都以对方的对象


总结: 以后开发中,如果表1对多的关系.当创建这2个实体的时候
	     在一的一方定义一个多的一方的集合
	     在多的一方定义一个一的一方的对象

     以后开发中,如果表多对多的关系.当创建这2个实体的时候
	     在互相中都有对方的集合

     以后开发中,如果表一对一的关系.当创建这2个实体的时候
	     在互相中都有对方的对象
					



玩hibernate的一对多关系建立?

	任务:有2张表,有2个实体类
	     然后通过hibernate创建一对多的关系映射


	 一对多的配置: 固定方式
	   在多的一方(Linkman)
		<many-to-one name="customer" class="cn.itcast.domain.Customer" column="wj_id"></many-to-one>
		  name: 自己里面一的一方对象的属性名 :customer	
		  class: 一的一方的全限定名
		  column: 指定外键名

	   在一的一方(Customer)
		<set name="linkmans">
			<key column="wj_id"></key>
			<one-to-many class="cn.itcast.domain.Linkman"/>
		</set>

		set:配置集合
		   name:自己里面多的一方的集合属性名 linkmans
		   column: 指定外键名
		   class: 多的一方的全限定名

		
		

需求: 存一个客户一个联系人
	   客户的名字叫    马总
	   联系人的名字叫  小秘


保存的时候,确实保存成功 但是出现了一些冗余的sql语句
我们说这些冗余的sql语句(update)不影响我们的程序,但是影响了性能
能不能让这些冗余的sql语句不再出现了呢?

可以 

 产生原因: 一级缓存

 解决办法(掌握):
	  因为现在2方都知道外键的存在 那么2方都会维护外键
	  让其中一方放弃外键的维护即可解决
	  约定:让一的一方放弃外键的维护权 (customer)

	  在一的一方设定标签 :inverse="true" 
		      放弃外键的维护权


 
 产生的原理: 图



 级联:
	 级联:在操作自己数据的时候,会把自己关联的数据也给操作了

	 1 保存一的一方数据的时候能级联把多的一方数据也给保存了
	   级联是有方向性,反过来也能实现

	 2 删除一的一方数据的时候能级联把多的一方数据也给删除了
	   级联是有方向性,反过来也能实现

	cascade:save-update 级联保存  保存谁就在谁身上设置
	        delete      级联删除  删除谁就在谁身上设置
	  
	
	










					



						









级联操作的高级应用:

	测试:
		有一个客户和3个联系人

		让联系人1关联客户
		让客户关联联系人2和3 

		级联保存操作:
			  save(联系人1)  // 问: 会发送几条sql语句? 

			  save(客户)  // 问:会发送几条sql语句? 
		
			  save(联系人2) // 问:会发送几条sql语句? 









对象导航的查询(关联关系的查询---多表数据的查询)

1 根据一个客户,查询这个客户下面所有联系人的数量


2 根据一个联系人,查询这个客户的名称



企业开发:

一对多要一方放弃外键的维护
	    一的一方放弃  inverse="true"

多对多也要一方放弃外键的维护
	    被动的一方    inverse="true"



总结hibernate的查询:
	  OID查询  根据主键查询一条对象的数据

	  HQL查询  全查 条件查 分页查 投影查 单列查 多列查 聚合查 排序查

	  QBC查询  明天讲

	  对象导航查询:
		         当你在查customer数据的时候 会把customer中的集合linkman数据也全查了
	
	class customer
	{
		cust_id
		cust_name

		private set<linkman> linkmans=new HashSet<Linkman>()
	
	}

	class linkman
	{
		lkm_id
		lkm_name

		private Customer customer;
	
	}


	使用对象导航查询做例子:
		 1  查询客户下面所有的联系人数量?
				Customer customer=session.get(Customer.class,1L); 
				customer.getLinkmans.size();

		 2 查询当前联系人的所属客户名字?
				linkman linkman=session.get(linkman.clss,1L);
				linkman.getCustomer.getname();









				
				
				