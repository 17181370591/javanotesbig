3大块较重要的东西分散在各处，复制粘贴到一起


servlet上传：

前端3要素： multipart/form-data  post  type=file		
	<form enctype="multipart/form-data" method="post" 	action='/d2/product?method=pic'>
		<input type='file' name='fn'/>upload
		<input type='text' name='u' value='u1'/>
		<input type='submit' value='submit'/>
	</form>
这个请求会先通过baseservlet处理，得到method(pic)后调用productservlet的pic方法，
但是enctype="multipart/form-data"的表单无法通过request.getParameter获取，
所以action=/d2/product然后用隐藏域提交method=pic会无法进入pic方法，
这里写成了/d2/product?method=pic。

后台代码(fc,upload,fileitem都来自commons-fileupload包)：
public String pic(HttpServletRequest r, HttpServletResponse s) throws Exception {
		String u = r.getParameter("u");
		String fn = r.getParameter("fn");
			//始终打印null --null
		System.out.println(u + "\t--" + fn);
		DiskFileItemFactory fc = new DiskFileItemFactory();
		ServletFileUpload upload = new ServletFileUpload(fc);
		List<FileItem> list = upload.parseRequest(r);
		Map<String, List<FileItem>> map = upload.parseParameterMap(r);
			//list能获取到，map是null
		System.out.println(list);
		System.out.println(map);
		for (FileItem item : list) {
				// 文件的输出是			fn:一堆乱码		01.jpg:false
				// u=1111的输出是		u:u1111 		null:true
			System.out.print(item.getFieldName() + ":" + item.getString());
			System.out.println("\t"+item.getName() + ":" + item.isFormField());
			if (!item.isFormField()) {
				File file = new File( "e:/" + item.getName());
				InputStream in = item.getInputStream();
				FileOutputStream out = new FileOutputStream(file);
				byte[] b = new byte[1024];
				int len = 0;
				while ((len = in.read(b)) != -1) {
					out.write(b, 0, len);
				}
				in.close();
				out.close();
			}
		}
		return null;
	}

===================================================

serlvet下载并解决中文文件名乱码问题(包括火狐浏览器)：	
重点两个：1个是结论文件名乱码的通用方法2，更重要的是mimetype设置成application/octet-stream可以通用的处理下载文件，即s.setHeader("content-type", "application/octet-stream");

	public class S2 extends HttpServlet {
	@Override
	protected void doGet(HttpServletRequest r, HttpServletResponse s) throws ServletException, IOException {
	
		ServletContext sc = getServletContext();
			//filename是乱码，因为浏览器的中文经过utf8编码传给服务器，
			//服务器在is08859-1编码得到filename，所以还原需要用同样的方法
		String filename = r.getParameter("filename");

			//用is08859-1解码再用utf-8编码，得到原文件名filename1。方法1：
		//byte[] bytes = filename.getBytes("iso8859-1");
		//String filename1 = new String(bytes, "utf-8");
			//方法2：
			//两种方法都能得到原文件名，似乎方法2更好，因为得到f3也是字符串
		String f3 = URLEncoder.encode(filename, "iso8859-1");
		String filename1 = URLDecoder.decode(f3, "utf-8");
				
		byte[] b = new byte[1024];
		String p = sc.getRealPath("myjpg/" + filename1);
		String mimeType = sc.getMimeType(p);
			//这里根据文件类型得到mimetype，根路径无关，jpg的mimetype是image/jpeg

		s.setHeader("content-type", mimeType);				//必须设置1
		//s.setContentType("application/octet-stream");
		//设置成application/octet-stream更好，适用于任意类型文件
			
			
		//String cd = "attachment;filename=" + filename1;		//头1
		String cd = "attachment;filename*=utf-8'zh_cn'" + f3;	//头2
			//一般浏览器用头1就可以解决中文乱码问题，但火狐不行，通用方法是头2
		s.setHeader("content-disposition", cd);				//必须设置2
				
		FileInputStream f = new FileInputStream(p);
		ServletOutputStream outputStream = s.getOutputStream();
		int len = 0;
		while ((len = f.read(b)) != -1) {
			outputStream.write(b, 0, len);
		}
	}
	
=================================================

servlet异常处理：似乎只能在每个方法内try/catch

=================================================

servlet ajax：
		String s = JSON.toJSONString(data);
		response.setCharacterEncoding("utf-8");
		response.getWriter().write(s);


===============================================================================

struts2上传：

	<!-- struts.xml里添加下面这行：上传时文件稍大会报错，需要配置大小限制
	<constant name ="struts.multipart.maxSize" value ="100000000"/> -->
	
前端：
	<form action="${pageContext.request.contextPath}/up/upload.action" enctype="multipart/form-data" method="post">
		<input type="file" name="UpImg">
		<input type="text" name="x" value='xxx'>
		<input type="submit" value="上传">
	</form>
	
后端：
	@ParentPackage("struts-default")
	@Namespace("/up")
	@Action
	public class UploadAction extends ActionSupport {
		private static final long serialVersionUID = 1L;
	
	//UpImg要和前端的type=file的name相同，下面两个属性名明显由UpImg决定
		private File UpImg;		
		private String UpImgContentType;
		private String UpImgFileName;
		private String x;

		public String getX() {
			return x;
		}

		public void setX(String x) {
			this.x = x;
		}

		@Action(value = "upload")
		public String upload() throws Exception {
			System.out.println("------execute----");
			System.out.println("------UpImg----" + UpImg);
			System.out.println("------UpImgContentType----" + UpImgContentType);
			System.out.println("------UpImgFileName----" + UpImgFileName);
			// 获取项目绝对路径+upload相对路径
			String contextPath = ServletActionContext.getServletContext().getRealPath("/upload");
			System.out.println("项目的文件路径" + contextPath);
			File destFile = new File(contextPath, UpImgFileName);
			FileUtils.copyFile(UpImg, destFile);
			return NONE;
		}

		public void setUpImg(File upImg) {
			UpImg = upImg;
		}

		public void setUpImgContentType(String upImgContentType) {
			UpImgContentType = upImgContentType;
		}

		public void setUpImgFileName(String upImgFileName) {
			UpImgFileName = upImgFileName;
		}
	}
	
================================================

struts2下载：

================================================

struts2异常处理：
见 \xml配置文件\struts2的配置\struts2全局异常处理.txt

===============================================

struts2 ajax：不需要其他任何配置
	@Action(value = "roleAction_ajax")
	public String ajax() throws IOException {
		Set<Module> mm = ds.get(d.getId()).getModules();
		HttpServletResponse r = ServletActionContext.getResponse();
		String s = JSON.toJSONString(mm);
		r.setCharacterEncoding("utf-8");
		r.getWriter().write(s);
		return null;
	}
	
====================================================================================

springMVC上传：

1、导包：<dependency>
			<groupId>commons-io</groupId>
			<artifactId>commons-io</artifactId>
			<version>2.2</version>
		</dependency>
		<dependency>
			<groupId>commons-fileupload</groupId>
			<artifactId>commons-fileupload</artifactId>
			<version>1.3.1</version>
		</dependency>
		
2、在springMVC.xml里配置文件解析器
	 <!-- 文件上传 -->
	<bean id="multipartResolver"
		class="org.springframework.web.multipart.commons.CommonsMultipartResolver">
		<!-- 设置上传文件的最大尺寸为5MB -->
		<property name="maxUploadSize">
			<value>5242880</value>
		</property>
	</bean>
	
3、上传代码如下，pictureFile必须和表单的<input type="file"  name="pictureFile"/> 一一对应。可能报错MultipartFile Specified class is an interface，MultipartFile前加上@RequestParam可以解决。
	@RequestMapping("/updateitem")
	public String updateitem(MultipartFile pictureFile) throws Exception{
		String ss=pictureFile.getOriginalFilename();
		int lastIndexOf = ss.lastIndexOf(".");
		String s1=UUID.randomUUID().toString();
		ss="d:/up/"+s1+ss.substring(lastIndexOf);
		
		//保存文件
		pictureFile.transferTo(new File(ss));
		return "redirect:list.action";		
	}
	
	
ajax请求不能上传文件，所以不能用MultipartFile pictureFile，不然会报错表单不是multipart，当时没注意，以为老师的代码用ajax上传文件，一直试图模仿，白白浪费了一个多小时。@ResponseBody加在方法上表明是ajax请求。

=====================================================

springMVC下载，完全使用servlet的下载：

@Controller
@RequestMapping("/goods")
public class GoodsController2 {
	@RequestMapping("/down")
	public void search(HttpServletRequest r, HttpServletResponse h) throws Exception {
		String realPath = r.getRealPath("/img/024.jpg");
		System.out.println(realPath);
		h.setHeader("content-type", "application/octet-stream");
		String cd = "attachment;filename=1.jpg";
		h.setHeader("content-disposition", cd);
		FileInputStream f = new FileInputStream(realPath);
		byte[] b = new byte[1024];
		int len;
		while ((len = f.read(b)) != -1) {
			h.getOutputStream().write(b, 0, len);
		}
		f.close();
	}
}

===================================================

springMVC异常处理：
Web工程中一般都是三层结构，如果系统中无论那一层发送异常都可以直接向上抛出，而不用处理，最后由springmvc前端控制器交由异常处理器进行处理。

自定义异常处理器：
	public class MyExceptionResolver implements HandlerExceptionResolver {
		@Override
		public ModelAndView resolveException(HttpServletRequest request, HttpServletResponse response, Object handler,
				Exception ex) {
			ModelAndView modelAndView = new ModelAndView();
			modelAndView.addObject("message", ex.getMessage());
			modelAndView.setViewName("error.jsp");
			return modelAndView;
		}
	}
	
错误页面里有${message}可以查看错误信息

在springmvc.xml中添加：
<!-- 异常处理器 -->
<bean id="handlerExceptionResolver" class="cn.me.exception.MyExceptionResolver"/>

=====================================================

springMVC ajax：

	前端代码：
    <script type="text/javascript">
    	data={'user':'user11','pw':'pw11'};
    	data=JSON.stringify(data);
    /* 	data=$("#form1").serialize();  */
    	alert(data);
    	$.ajax({
    		'type':'post',
    		'url':'ajax1.action',
    		/* data:JSON.stringify(data), */
    		data:data,
    		dataType:'json',
    		contentType: "application/json",
    		'success':function(d){alert(JSON.stringify(d))},
    		'error':function(){alert(1)},
    	})
    </script>
	
	后端代码：
	@RequestMapping("ajax1")
	@ResponseBody
	public Map ajax1(@RequestBody User u) throws IOException {
		Map m = new HashMap();		
		m.put("a", 1);		
		return m;
	}
	
@ResponseBody注解：
服务端传json给客户端本来需要将java对象转成json字符串再返回字符串，使用这个注解可以直接返回java对象，转换操作由spring处理
	
@RequestBody注解：
用在形参上，把浏览器传来json字符串对应值赋值给形参对象。比如@RequestBody User u的User有user,pw,phone属性，json字符串是"{'user':'a','pw':'b'}"，则u的user=a,pw=b,phone=null，这个参数对传来的json字符串要求非常严格，必须是刚刚的格式。
https://jingyan.baidu.com/article/624e7459069f4034e8ba5a87.html

===========================================================================
	
	$('#releaseComment').click(function(){
		data={'commentContent':1,"commentTitle":2,'aid':3};
		$.ajax({
			url : '/article/releaseComment?aaa=bbb',
			type : 'post',
			dataType:'json',
			data : JSON.stringify(data),
			contentType : "application/json",
			success : function(v) {					
				.....
			},
			error:function(v){
				.....
			}
		})
	})

	上面代码里data里的参数后台必须用@RequestBody接收,比如public void releaseArticleForm(@RequestBody Map map),
	可以用map接收再转换。aaa写在url里，可以直接接收。
	
===========================================================================

补充：用ajax上传文件到springMVC

配置同上，
	前台代码：
	$('#saveProfileButton').click(function(){			
		if($('#profileForm').data("bootstrapValidator").isValid()){			

			var form = new FormData();
			form.append('nickname',$('input[name="nickname"]').val());
			form.append('introduction',$('textarea[name="introduction"]').val());
			form.append('pictureFile',$('input[name="pictureFile"]')[0].files[0]);
			
			console.log(form);
			$.ajax({
				url:'/user/saveProfile',
				type:'post',
                data:form,
                processData:false,
                contentType:false,
				success:function(v){
					alert(JSON.stringify(v))
				},
				error:function(v){
					alert('ee')
				}
			})
		}
	})
	
	后台代码：
	public JDSResult saveProfile(MultipartFile pictureFile, HttpSession s, HttpServletRequest request) {
		try {
			MultipartHttpServletRequest multipartRequest = (MultipartHttpServletRequest) request;
			String nickname = multipartRequest.getParameter("nickname");
			String introduction = multipartRequest.getParameter("introduction");

			String fileName = pictureFile.getOriginalFilename();
			int lastIndexOf = fileName.lastIndexOf(".");
			String uuidFileName = UUID.randomUUID().toString().replace("-", "");

			if (!new File(filePath).exists()) {
				new File(filePath).mkdirs();// 如果目录不存在，则创建目录
			}
			String filePath1 = uuidFileName + fileName.substring(lastIndexOf);
			pictureFile.transferTo(new File(filePath + filePath1));

			return new JDSResult(true, "保存成功");
		} catch (Exception e) {
			return new JDSResult(false, e.getMessage());
		}

	}
