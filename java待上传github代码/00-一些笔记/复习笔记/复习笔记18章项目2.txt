第18章品优购：

================================================================================
day01

1、classpath*和classpath的区别：
dao模块引用了pojo模块，web模块引用dao，dao、pojo和web的resource下有db.properties，pojo还有/1/db.properties，加载dao的spring配置文件，通过log4j输出spring的debug可以发现，<context:property-placeholder location="classpath:db.properties" />可以加载dao的db.properties，classpath*:db.properties可以加载dao和pojo的共2个，classpath*:**/db.properties可以加载dao和pojo和pojo/1/的共3个。
结论是classpath加载当前的，classpath*加载当前和引用的，**表示任意层级，classpath*速度慢，避免使用

2、web.xml的classpath*:applicationContext*.xml解决spring注入失败：
sellergoods-service层引用dao层，sellergoods-service是war项目，启动项目注册服务到dubbo时报错BrandMapper找不到，原因是sellergoods-service层的web.xml里配置的是classpath:applicationContext*.xml，所以启动时dao层的BrandMapper没有被spring实例化，修改即可

3、dubbo报错must implement java.io.Serializable，将TbBrand实现实例化依旧报错，重启sellergoods-service项目即可

4、在类上加@RestController相当于同时在类似加@ResponseBody和@Controller

================================================================================
day02

1、第一次访问brand的List页面会发送两次请求，关键代码如下：
	scope.$watch(function() {
		if(!scope.conf.totalItems) {
			scope.conf.totalItems = 0;
        }
		var newValue = scope.conf.totalItems + ' ' +  scope.conf.currentPage + ' ' + scope.conf.itemsPerPage;
		return newValue;
	}, getPagination);
	
检测scope变量，每次改变会返回页面的数据条数，当前页面和每页数据，并调用getPagination方法。getPagination里调用了scope.conf.onChange()，在List页面scope.conf对象有onChange : function() {	$scope.reloadList(); //重新加载},即把方法作为value，这样就相当于调用了$scope.reloadList()。

第一次访问oldValue和newValue是0 1 10和0 1 10(需要调用onChange)，访问后由于totalItems被修改再次调用，这时oldValue和newValue是0 1 10和22 1 10，非第一次访问比如从第一页跳到第二页时oldValue和newValue是22 1 10和22 2 10，显然第一次访问的第二次调用是多余的，解决办法是List页面设置scope.conf没有totalItems属性并如下修改getPagination：
	if(!(oldValue != newValue && oldValue[0] == '0')) {
		scope.conf.onChange();
    }

2、分页方法：见 例子/使用angular_githubpagehelper分页.txt

3、删除品牌和全选/反选：
需要删除的品牌的id保存到ids，全选框加上ng-model='allc'，其他checkbox加上ng-checked='allc'即完成全选/反选，并监控allc来添加和清空ids。记得每次reloadList都要初始化这两个值

		$scope.ids = [];
		$scope.allc = false;
		$scope.check = function(id) {
			i = $scope.ids.indexOf(id);
			if (i == -1) {
				$scope.ids.push(id);
			} else {
				$scope.ids.splice(i, 1);
			}
		}
		
		$scope.$watch('allc', function() {
			$scope.ids = [];
			if ($scope.allc == true) {
				l = $scope.list;
				for (i = 0; i < l.length; i++) {
					$scope.ids.push(l[i].id)
				}
			}
		})

4、条件查询
页面用searchEntity接收查询的参数，使用post请求(用get要拆开searchEntity再拼接url)，一定要有初始化的searchEntity，不然第一次进入页面会报错参数错误，因为后台post方法使用了@RequestBody，还有注意这个post请求也拼接了参数，前端代码如下：

		$scope.searchEntity={};
		$scope.search=function(){
			page=$scope.paginationConf.currentPage;
			rows=$scope.paginationConf.itemsPerPage;
			url = '/brand/search.do?pageNum=' + page + '&pageSize=' + rows;
			$http.post(url,$scope.searchEntity).success(
				function(response) {
					$scope.list = response.rows;
					$scope.paginationConf.totalItems = response.total; 
					$scope.ids = [];
					$scope.allc=false;
				}
			);
		}

controller代码如下：		
	@RequestMapping("/search")
	public PageResult<TbBrand> search(int pageNum, int pageSize, @RequestBody TbBrand entity) {
		return brandService.findPage(pageNum, pageSize, entity);
	}

实现层代码如下：	
	public PageResult<TbBrand> findPage(int pageNum, int pageSize, TbBrand entity) {
		String fc = entity.getFirstChar();
		String name = entity.getName();
		TbBrandExample e = new TbBrandExample();
		if (fc != null && !fc.trim().equals("")) {
			e.createCriteria().andFirstCharEqualTo(fc);
		}
		if (name != null && !name.trim().equals("")) {
			e.createCriteria().andNameLike("%" + name + "%");
		}
		PageHelper.startPage(pageNum, pageSize);
		List list = brandMapper.selectByExample(e);
		PageInfo pageInfo = new PageInfo(list);
		PageResult pageResult = new PageResult(pageInfo.getTotal(), list);
		return pageResult;
	}
	
================================================================================
day03

1、angularjs的service层和web层分离
	app.controller('brandController', function($scope, $http) {
		$scope.search()=function(){
			$http.post('/brand/list.do?id='+$scope.id,$scope.data).success(
				function(response) {
					$scope.reloadList();
				}
			);
		}
	}
	可以拆分成
	app.controller('brandController', function($scope,brandService) {
		$scope.search()=function(){
			brandService.search($scope.id,$scope.data).success(
				function(response) {
					$scope.reloadList();
				}
			);
		}
	}
	app.service('brandService', function($http) {
		// 查询
		this.search=function(id,data){
			return $http.post('/brand/list.do?id='+id,data)
		}
		// 查询所有
		this.findAll = function() {
			return $http.get("../brand/findAll");
		};
		.........
	}

2、angularjs的抽取
var app = angular.module('pyg', ['pagination])或者var app = angular.module('pyg', [])是每个页面都要用的，抽出来放到base/base2.js
brandController部分放到brandController.js，brandService部分放到brandService.js
然后在原页面引用这3个js即可

3、angularjs的继承
brandController里分页的变量和方法可以抽取出来重用，这里使用继承来实现：

把需要重用的代码放到baseController.js里，内容如下：
	app.controller('baseController', function($scope) {
		需要被继承的代码...
	}
brandController内容如下：
	app.controller('brandController', function($scope,$controller,brandService){	
		$controller('baseController',{$scope:$scope});
		不需要被继承的代码...
	}
页面里需要引入这两个js，baseController必须放在brandController前面	

4、angularjs处理对象列表：
需要增删改查规格和规格下的规格选项(比如规格是颜色，选项是红黄等)，需要创建规格时点击 新增规格选项 生成新的空白选项供输入，点击 选项的删除可以删除该选项，修改时取后台查询规格和拥有的选项，并展示。前台代码如下，需要注意的是$index和e.olist.push({})。后台代码添加规格时需要给选项设置规格的id，mapper.xml里需要加上<selectKey resultType="int" keyProperty="id" order="AFTER">select last_insert_id()</selectKey>，删除时要先用deleteByExample删除拥有的选项，修改时需要删除所有选项再重新添加。

		 <div class="btn-group"><button ng-click='addOlist()'>
			{{entity.id}}新增规格选项{{entity.olist}}
		</button></div>		 
		 <table><tbody><tr ng-repeat='x in entity.olist'>                           
				<td><input ng-model='x.optionName'></td>
				<td><input ng-model='x.orders'></td>
				<td><button ng-click='delOlist($index)'>删除</button></td>
         </tr></tbody></table> 
    
	$scope.addOlist=function(){
		e=$scope.entity;
		if(e.olist==null){
			e.olist=[];
		}
		e.olist.push({});
	}
	$scope.delOlist=function(id){
		$scope.entity.olist.splice(id,1);
	}

5、select2用法见  00-一些笔记\angularjs笔记.txt
	
================================================================================
day04

1、springSecurity配制见 xml配置文件\其他配置\springSecurity配置

2、fastdfs配制见  xml配置文件\其他配置\fastdfs配置

================================================================================
day06:

1、js深拷贝	JSON.parse(JSON.stringify(Object))
newRow由oldRow深拷贝获得，所以修改newRow不会对list造成影响
	addColumn=function(list,columnName,conlumnValues){
		var newList=[];//新的集合
		for(var i=0;i<list.length;i++){
			var oldRow= list[i];
			for(var j=0;j<conlumnValues.length;j++){
				var newRow= JSON.parse( JSON.stringify( oldRow )  );//深克隆
				newRow.spec[columnName]=conlumnValues[j];
				newList.push(newRow);
			}    		 
		} 		
		return newList;
	}

================================================================================
day07：

1、千万注意想要事务生效数据库的表的engine必须是innodb，@Transactional和@Service的顺序没影响

================================================================================
day12：

1、freemarker笔记 见 00-一些笔记\复习笔记

2、js遍历对象：
	
<script>
	   var skuList=[    	    
		    		{
		    		"id":"id1",
		    		"name":"name1",	
		    		} ,     		
		    		{
		    		"id":"id2",
		    		"name":"null_name",	
		    		} ,     		
		    		{
		    		"id":"null_id",
		    		"name":"name3",	
		    		} ,     		
		    		{
		    		"id":"id4",
		    		"name":"name4",	
		    		} ,     		
	   ];  
	   console.log(skuList);
	   	for(var k in skuList){
			console.log(skuList[k]);
		}					
</script>

输出如下：
{id: "id1", name: "name1"}
{id: "id2", name: "null_name"}
{id: "null_id", name: "name3"}
{id: "id4", name: "name4"}

================================================================================
day14：
1、springboot：见 xml文件配置的springboot配置

2、快速生成方法的注释的快捷键：alt+shift+j

3、比较Long的值：
	public void t11() {
		Long l1 = new Long(123);
		Long l2 = new Long(123);
		System.out.println((l1 == l2) + "\t" + l1.equals(l2));
		System.out.println(l1.toString() == l2.toString());
		System.out.println(l1.toString().equals(l2.toString()));
		System.out.println(l1.longValue() == l2.longValue());
	}
	//false	true		//false			//true		//true
    public boolean equals(Object obj) {
        if (obj instanceof Long) {
            return value == ((Long)obj).longValue();
        }
        return false;
    }
l1和l2是对象，直接用==比较会比较地址，肯定不一样；equals方法被重写了，变成longValue值的比较。toString返回的是String对象，==也比较地址，所以String尽量用equlas比较
	
================================================================================

day17：
1、跨域请求,详情见 00-一些笔记\复习笔记\跨域请求.txt

2、twitter的IdWorker: 一个分布式的ID生成工具,工具类见utils包的IdWorker.java
使用方法1：
	@Test	//k可以看二进制数据，不需要
	public void tt11() {
		IdWorker id = new IdWorker(0, 0);
		for (int i = 0; i < 10; i++) {
			long j = id.nextId();
			String k = Long.toBinaryString(j);
			System.out.println(j + "\t" + k);
		}
	}
使用方法2：
	<bean id="iw" class="util.IdWorker">
		<constructor-arg value="0" />
		<constructor-arg value="0" />
	</bean>
	@Autowired
	private IdWorker i;
	@Test
	public void tt() {
		System.out.println(i + ":" + i.nextId());
	}
	
================================================================================


