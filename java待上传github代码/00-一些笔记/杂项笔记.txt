用tomcat测试发现，只要cookies里JSESSIONID一样，就会被服务器认为是同一个session。
（session的地址一样，且对一个session设置attri，另一个id一样的session能访问该值。


上下文的attri，任何访问都能看到

==================================================================================
bootstrap样例：https://v3.bootcss.com/css/#overview
https://www.runoob.com/bootstrap/bootstrap-modal-plugin.html   这个貌似更好
https://www.runoob.com/bootstrap4/bootstrap4-tables.html     这个更好，bootstrap4
==================================================================================

增强某个方法，有三种方法：
1，知道方法的类。直接用继承重写；
2，不知道类，知道接口且接口只有少数方法。用修饰器；
3，用动态代理。下面的代码是用filter增强getParameter，使其解决utf8乱码

public void doFilter(ServletRequest r1, ServletResponse s, FilterChain chain) throws IOException, ServletException {
		HttpServletRequest r = (HttpServletRequest) r1;
		HttpServletRequest r2 = (HttpServletRequest) Proxy.newProxyInstance(
				r.getClass().getClassLoader(),
				r.getClass().getInterfaces(), 
				new InvocationHandler() {
					@Override
					public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
						if ("getParameter".equalsIgnoreCase(method.getName())) {
							String m = r.getMethod();
							if ("get".equalsIgnoreCase(m) || "post".equalsIgnoreCase(m)) {
								String a = (String) method.invoke(r, args);
								if (a != null) {
									a = new String(a.getBytes("iso-8859-1"), "utf-8");
									return a;
								}
							}
						}
						return method.invoke(r, args);
					}
				});
		chain.doFilter(r2, s);
	}

==================================================================================

配置文件模板在
资料\spring-framework-4.2.4.RELEASE-dist\spring-framework-4.2.4.RELEASE\docs\spring-framework-reference\html

==================================================================================

07stores里有ajax中文乱码的解决方法
bean里写了带参数的构造方法就一定要写无参的！！不然BeanListHandler无法构造bean，bug都找不到

==================================================================================

default.properties在Web App Libraries/struts2-core-2.3.24.jar/org.apache.struts2/default.properties

覆盖加载：

方法1（推荐）：  在struts2.xml里设置	 ，比如：
<constant name="struts.action.extension" value="action"></constant>


方法2： 在web.xml的filter里设置init-param,比如：
  <filter>
  	<filter-name>struts2</filter-name>
  	<filter-class>org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter</filter-class>
  	<init-param>
  		<param-name>struts.action.extension</param-name>
  		<param-value>xyz</param-value>
  	</init-param>
  </filter>


===========================================================================================

	<package name="A" extends="struts-default" namespace="/">
		<interceptors>
			<interceptor name="i1" class="com.interception.I1"></interceptor>
			<interceptor name="i2" class="com.interception.I2"></interceptor>			
		</interceptors>		


		<action name="a_*" class="com.action.A"  method="a{1}">
			<result  name="login">/1.jsp</result>
			<result name="zhucefailed">/WEB-INF/3.jsp</result>
			<result name="zhucesuccess">/WEB-INF/3.jsp</result>			
			<result name="index">/index.jsp</result>
			<result name="fff">/WEB-INF/2.jsp</result>
			<result type="redirectAction">a_f</result>

			<interceptor-ref name="i1">
				 <param name="excludeMethods">a1,a2</param>
			</interceptor-ref>
			<interceptor-ref name="i2"></interceptor-ref>
			<interceptor-ref name="defaultStack"></interceptor-ref>
		</action>	
	</package>
  
  直接使用redirect的方法无法访问web-inf下面的页面，可以用redirectAction重定向，
  然后在相应的地方用请求转换的方法跳转web-inf下面的页面
  
  
  
==================================================================================

ctrl+shift+L可以补全=左边的变量

==================================================================================


在项目的hibernate的配置文件hibernate.cfg.xml里修改name为“hibernate.connection.url"的property的值为：
          jdbc:mysql://localhost:3306/tdm?useUnicode=true&amp;characterEncoding=UTF-8，其中tdm为数据库的名称
		  

==================================================================================

hql语句_直接查询数组里的id
public interface ContractProductDao extends JpaRepository<ContractProduct, String>,JpaSpecificationExecutor<ContractProduct>{
	@Query(countQuery="select * from contractproduct_p where contract_id=?")
	public List<ContractProduct> findByContractId(String i);
	
	@Query(value="from ContractProduct where to_char(contract.shipTime,'yyyy-MM') = ?1")
	public List<ContractProduct> findCpByShipTime(String shipTime);
	
	//根据购销合同id集合一次性查询购销合同货物
	@Query(value="from ContractProduct where contract.id in (?1)")
	public List<ContractProduct> findCpByContractIds(String[] ids);
}

===========================================================================================

1、pageEncoding="UTF-8"的作用是设置JSP编译成Servlet时使用的编码。 
2、contentType="text/html;charset=UTF-8"的作用是指定对服务器响应进行重新编码的编码。 
3、request.setCharacterEncoding("UTF-8")的作用是设置对客户端请求进行重新编码的编码。
4、response.setCharacterEncoding("UTF-8")的作用是指定对服务器响应进行重新编码的编码。 
response.setCharacterEncoding("UTF-8")的作用是指定对服务器响应进行重新编码的编码。同时，浏览器也是根据这个参数来对其接收到的数据进行重新编码（或者称为解码）。所以在无论你在JSP中设置response.setCharacterEncoding ("UTF-8")或者response.setCharacterEncoding("GBK")，浏览器均能正确显示中文（前提是你发送到浏览器的数据编码是正确的，比如正确设置了pageEncoding参数等）。

 

对于发送数据，服务器按照response.setCharacterEncoding—contentType—pageEncoding的优先顺序，对要发送的数据进行编码。 

对于接收数据，要分三种情况。一种是浏览器直接用URL提交的数据，另外两种是用表单的GET和POST方式提交的数据。

 

对于表单中POST方式提交的数据，只要在接收数据的JSP中正确request.setCharacterEncoding参数，即将对客户端请求进行重新编码的编码设置成浏览器编码，就可以保证得到的参数编码正确。有写读者可能会问，那如何得到浏览器编码呢？上面我们提过了，在默认请情况下，浏览器编码就是你在响应该请求的JSP页面中response.setCharacterEncoding设置的值。所以对于POST表单提交的数据，在获得数据的JSP页面中request.setCharacterEncoding要和生成提交该表单的JSP页面的 response.setCharacterEncoding设置成相同的值。 

对于URL提交的数据和表单中GET方式提交的数据，在接收数据的JSP中设置request.setCharacterEncoding参数是不行的，因为在Tomcat5.0中，默认情况下使用ISO- 8859-1对URL提交的数据和表单中GET方式提交的数据进行重新编码（解码），而不使用该参数对URL提交的数据和表单中GET方式提交的数据进行重新编码（解码）。要解决该问题，应该在Tomcat的配置文件的Connector标签中设置useBodyEncodingForURI或者 URIEncoding属性，其中useBodyEncodingForURI参数表示是否用request.setCharacterEncoding 参数对URL提交的数据和表单中GET方式提交的数据进行重新编码，在默认情况下，该参数为false（Tomcat4.0中该参数默认为true）； URIEncoding参数指定对所有GET方式请求（包括URL提交的数据和表单中GET方式提交的数据）进行统一的重新编码（解码）的编码。 URIEncoding和useBodyEncodingForURI区别是，URIEncoding是对所有GET方式的请求的数据进行统一的重新编码（解码），而useBodyEncodingForURI则是根据响应该请求的页面的request.setCharacterEncoding参数对数据进行的重新编码（解码），不同的页面可以有不同的重新编码（解码）的编码。所以对于URL提交的数据和表单中GET方式提交的数据，可以修改 URIEncoding参数为浏览器编码或者修改useBodyEncodingForURI为true，并且在获得数据的JSP页面中 request.setCharacterEncoding参数设置成浏览器编码。


--------------------- 
作者：fancylovejava 
来源：CSDN 
原文：https://blog.csdn.net/fancylovejava/article/details/7700683 
版权声明：本文为博主原创文章，转载请附上博文链接！

=============================================================================

右键项目名称,web deployment assembly，add-->java build path entries，
每次在maven里update project都要重复这个操作。
=============================================================================
jsp和java似乎无法直接获取浏览器的地址栏里的地址，可以用$(location)[0].href获取

=============================================================================
使用filter拦截请求，被拦截的请求早请求转发或者重定向后必须return，否则可能出现奇怪的bug：
Cannot call sendRedirect() after the response has been committed 。

=============================================================================
必须在bean里设置set方法，dbutils里面的beanhandler方法才能设置相应的值。

=============================================================================
redis可以直接用get和set保存获取json。比如用beanlisthandler从mysql获取的数据，用gson转成json后可以直接保存。
因为json本身就是String

=============================================================================

设置a标签无效，
href=""
a.disabled {
    pointer-events: none;
}


=============================================================================
 1. jQuery AJAX 请求,后台收到为乱码
可以显式设置contentType的编码为utf-8, 后台一般都能正常解码例如：
contentType: "application/x-www-form-urlencoded; charset=utf-8", 
 
jQuery(form).ajaxSubmit({url: "doLogin?user=a",type: "post",dataType: "json",
      contentType: "application/x-www-form-urlencoded; charset=utf-8",success: showLoginResponse});  

如果不加contentType: "application/x-www-form-urlencoded; charset=UTF-8",  而使用escape(),则会出现
post 主体包含的字节比内容长度指定的字节要少
的错误.
 
2.  jQuery AJAX 返回乱码
你是否发现无论你怎么设置编码, 客户端收到的数据总是乱码呢, 请看下面的例子,你发现有什么问题吗?
void saveTempKind(HttpServletRequest req, HttpServletResponse resp)            throws ServletException, IOException {  
PrintWriter pw = resp.getWriter(); resp.setContentType("text/text;charset=GBK");  
try {  //DO PROCESS   pw.write("成功"); }catch(Exception e){  pw.write("失败"); }}  
问题在于resp.setContentType("text/text;charset=GBK");
语句应该在PrintWriter pw = resp.getWriter();之前,而不是之后。如果象上例这样，无论你怎么设置response的编码，前端乱码的问题都依然如故。 可能的原因是pw在获得PriintWriter 之前,编码就已经确定了。
所以编码的声明应该在获取PrintWriter对象之前。

本文来自 hongweigg 的CSDN 博客 ，全文地址请点击：https://blog.csdn.net/hongweigg/article/details/6756278?utm_source=copy 


==========================================================================================================================================================

导入jsp-api的包，在jsp文件前面加上
<%@taglib prefix="s" uri="/struts-tags" %>

遍历语法如下：
 		<s:iterator value="lc" var="b">
 
				<s:property value="#b.cust_name"/>
   		</s:iterator> 
		
貌似domain的类一般都实现serializable接口。

=============================================================================

持久化类要遵循JavaBean的规范：
⑴ JavaBean 必须放在一个单独的包中
⑵ JavaBean 必须申明为 public class 即：必须是公有的类
⑶ JavaBean 的所有属性必须申明为 private 即：属性必须私有
⑷ 通过公有的 setter 方法和 getter 方法设值和取值    
⑸ 必须有一个公有无参构造方法
⑹ 编写代码要严格遵守 Java 程序的命名规范（这个不必须）
(7)必须提供一个OID作为主键（一般是long属性）
(8)最好使用包装类（int->Integer)
(9)不能用final修饰
(10)实现serializable接口。因为可能要读写到硬盘（钝化活化）。

生成数据库表时的默认值
基本类型：int 0
包装类：integer null

==============================================================================

domain的类写在dao层的java，然后在dao层的resouces同样的路径下hbm.xml，
例如Customer.java在src/main/java/cn/domain，
那么Custoemr.hbm.xml在src/main/resouces/cn/domain，否则会报错。

=============================================================================

源码里汉字乱码(这个可能导致源码报错)：
windows--->Perfences-->general-->content types-->text-->java source file
-->default encoding(utf-8/gbk)-->update-->ok

====================================================================

开启多个tomcat7.0，复制tomcat软件，删除webapps的项目，修改conf/server.xml，
把所有端口修改(+1000)，在myeclipse添加tomcat7即可。


====================================================================

报错ClassNotFoundException: org.springframework.web.context.ContextLoad...:
https://www.cnblogs.com/aisam/articles/4686362.html
运行某项目时报错。工程WEB-INF目录下自动生成了lib目录，但没有jar包。
Properties-->Deployment Assembly-->Add-->Java Build Path Entries
-->Next-->Maven Dependencies-->Finish，然后可以看到已经把Maven Dependencies添加到Web应用结构中了。
在web项目中一般都需要将java文件以及资源文件发布到指定位置，其中deployment assembly的作用就在于此。如图web_Deployment_Assembly.jpg，
图表示java下的源码，resouce下的配置文件放在web-inf/classes里，
maven导入的jar放在web-inf/lib，其他放在根目录。

====================================================================

随便打开一个项目，点击项目里面的xml文件，然后返回重新创建maven工程，
use default workspace此时就变为空了。

====================================================================

  <listener>
      <listener-class> org.springframework.web.context.ContextLoaderListener</listener-class>
  </listener>
  <context-param>
       <param-name>contextConfigLocation</param-name>
       <param-value>classpath:applicationContext*.xml</param-value>
  </context-param>
  这样设置可以加载满足条件的applicationContext*.xml，
  不用再在applicationContext.xml里写
  <import resource="classpath:spring/applicationContext-ws.xml"/>。
  
====================================================================
maven项目里，web模块的classpath:applicationContext.xml里写<import resource="classpath:applicationContext-redis.xml"/>，
可以读取其他模块下src/main/resouce里的xml。

====================================================================

action不返回页面，即相应ajax,返回图片等return null时，回显无效，
因为回显数据在返回页面的。还有每次单独的请求都会使用新的action，
所以前一个action设置的私有属性的值，在下一个方法中无法获取。
例如注册页面，一个action获取验证码并回写到注册页面/显示到注册页面，
然后提交时会使用另一个action，无法校验，常用方法是放session或redis里。

====================================================================

maven主项目导的包，每个子模块都能用。子模块之间的依赖需要在pom里设置引用。

运行子模块时，子模块的applicationContext*.xml配置文件要配置各自的，
例如web子模块已经配置完成，与jms模块无关，jsm模块要在自己的web.xml配置，
最好是配置applicationContext*.xml，这样如果jms在pom引用了cache模块，
那么运行jsm也会在加载cache的xml文件，否则要在jsm的applicationContext.xml里写import。

====================================================================

ajax的type:post请求，data可以用和python一样的字典，
也可以换get方法把参数用=和&拼接起来放url后面。

====================================================================

在项目上右键，添加source folder，这个和src一样是是项目的根目录，起名config，
可以把配置文件放在config，这个文件夹里的文件在编译时和source放在一起。

====================================================================

junit测试方法3个规范：不能传参数，void，public。

====================================================================

项目有两个红点，window-->show view-->porblems可以看到哪个jar包有问题。

====================================================================

mybatis的排序方法如下：
		@Override
		public List<TbContent> findContentListByCategoryId(Long categoryId) {
			TbContentExample e=new TbContentExample();
			Criteria c = e.createCriteria();
			c.andCategoryIdEqualTo(categoryId).andStatusNotEqualTo("0");
			e.setOrderByClause("sort_order");
			e.setOrderByClause("INTERNAL_ID desc");		//逆序！！
			return contentMapper.selectByExample(e);
		}

====================================================================

ctrl+shift+f无法格式化，可能和搜狗输入法冲突，切换输入法即可。

====================================================================

Spring项目出现Referenced file contains errors的 解决方法

S运行项目的时候并没有错误，出现红色的x看起来很不舒服，在网上看的解决方法是清除Cache，
结果还是报错，反复搞了很久终于解决了：解决方法：
Window--Preferences--搜索“Validation”，去掉XML Validator 和 XSL Validator 等文件类型的验证信息(包括Manual和Build).

====================================================================

this和e.target的区别(this冒泡后者不冒泡)：
在tr里自定义了一个属性fid,tr下有h4标签，下面的代码可以把事件绑定到tr的整个后代元素里，
即点击h4也会触发。如果$(this)改成$(e.target)不会触发。还有fid不能用prop来获取。

	$box.children().find('tr[data-target]').click(function(e){
		console.log($(this),$(this).attr('fid'));
		
	})
	
====================================================================