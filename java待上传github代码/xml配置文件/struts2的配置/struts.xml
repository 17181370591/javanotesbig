<?xml version="1.0" encoding="UTF-8"?>
 <!DOCTYPE struts PUBLIC
	"-//Apache Software Foundation//DTD Struts Configuration 2.3//EN"
	"http://struts.apache.org/dtds/struts-2.3.dtd">
	
	
	
	
<!--下面这一段要剪切到web.xml	
 配置前端控制器  拦截所有的浏览器请求 -->
  <filter>
  	<filter-name>strust2_3</filter-name>
  	<!-- 在整个项目下搜资源:ctrl+shift+t -->
  	<filter-class>org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter</filter-class>
  </filter>
  
  <filter-mapping>
  	<filter-name>strust2_3</filter-name>
  	<url-pattern>/*</url-pattern>
  </filter-mapping>
	<!-- 如果整合spring框架，必须用下面的--> 
    <filter>
	  	<filter-name>struts2</filter-name>
	  	<filter-class>org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter</filter-class>
	  	<init-param>
	  		<param-name>struts.objectFactory</param-name>
	  		<param-value>spring</param-value>
	  	</init-param>
	  	<init-param>
	  			<param-name>struts.convention.package.locators</param-name>
	  			<param-value>web</param-value>
	  	</init-param>
  </filter>
  <filter-mapping>
  		<filter-name>struts2</filter-name>
  		<url-pattern>/*</url-pattern>
  </filter-mapping>
    <!-- 配置前端控制器 完毕--> 
	
	
	
	
	
	
<struts>
	
	
	<!-- 可以覆盖前面加载的配置文件内容，下面这句表示只过滤.action页面-->
	<!-- <constant name="struts.action.extension" value="action"></constant> -->
	
	<!-- 使用动态方法
	<constant name="struts.enable.DynamicMethodInvocation" value="true"></constant> -->
	
	<!-- name: 包名 对于咱们来说意义不大 作用:给别人继承用  
	extends: 继承  默认值:默认基层struts2提供的一个包 包名:struts-default
			 继承哪个包 那这个包下的所有东西都有一份
	
	namespace: 名称空间   和浏览器访问地址相关
	abstract:抽象的 默认是false 如果写成了true 代表当前的pageage下面不能出现action 他们2个是互斥的
		     该包只能被用来继承
	-->
	<!-- <package name="test1" extends="struts-default" namespace="/">
		 做action的地址访问路径 
		 	name:action的名字  和浏览器访问地址相关
			
		 	namespace和action的name：组成了当前action的访问地址，比如/user/add
			和/user/delete两个页面，可以放在同一个package，该package
			的namespace是/user，两个action的name分别是/add和/delete。
			name不能有层级关系，比如name=/add/one不会处理/user/add/one。
				 
		 	class:全限定名
		 	method: 可以不写 默认就是执行叫一个execute的方法，不用写括号和参数。。。
		
		 <action name="hello" class="cn.itcast.action.ActionDemo1" >
		 	result: 接收返回值 		 	
			name:action执行方法返回abc，则会返回abc对应的/jsp/demo.jsp
		 	<result name="abc">/jsp/demo.jsp</result>
		 </action>
	</package> -->
	
	
	
	
	<!-- 引入外部的action配置  -->
	<include file="struts_user.xml"></include> 
	
	
	<!-- action的3种创建方式 -->
	<package name="test3" extends="struts-default" namespace="/">
	
		<!--全局结果页面global-results：如下配置的话，该package处理的所有方法
		只要返回success就会跳转/error.jsp，某action覆盖它则该action走自己的;
		result的type定义跳转页面的方式，常见的有:
		dispatcher：默认，请求转发
		redirect：重定向
		chain：请求转发到action，比如<result name="a" type="chain">b</result>
			表示返回值为a的请求，用<result name="b">处理,如果
			<result name="b">/index.jsp</result>，则返回/index.jsp
		redirectAction：重定向到action		
		stream:文件下载，这个没用过								-->
		<global-results>
			<result name="success" type="redirect">/error.jsp</result>
		</global-results>
		
		<action name="hello2" class="cn.itcast.action.ActionDemo2" >
			<result name="success">/jsp/demo.jsp</result>
		</action>
		
		<action name="hello3" class="cn.itcast.action.ActionDemo3" >
			
		</action>
		
		<!-- action的3种访问方式 -->
		<!-- method方式 -->
		<action name="product_save" class="cn.itcast.action.ActionDemo4" method="save" >
	 	</action>
	 	<action name="product_delete" class="cn.itcast.action.ActionDemo4" method="delete" >
	 	</action>
	 	<action name="product_update" class="cn.itcast.action.ActionDemo4" method="update" >
	 	</action>
	 	<action name="product_find" class="cn.itcast.action.ActionDemo4" method="find" >
	 	</action>
	 	
	 	<!-- 通配符方式(掌握)  
	 			*: save
	 			   delete
	 			   update
	 			   find
	 			   
	 			{1} :第一个星号的值
	 	
	 	-->				 
	 	<action name="product_*" class="cn.itcast.action.ActionDemo4" method="{1}" ></action>
		 
		<action name="*_*" class="cn.itcast.action.{1}"  method="{2}" ></action>
	 	
	 	<!-- 动态方法方式(了解) 
	 			1 动态方法方式默认是关闭的  需要开启   default.properties
	 			2 页面要使用特殊写法，比如/user!add
	 	-->
	 	<action name="product" class="cn.itcast.action.ActionDemo4" ></action>
			 
	</package>
	
	
	
	
	
	

	
	
	
	
	<package name="CustomerDao1" extends="struts-default" namespace="/">
	
		<!-- 拦截器的配置方法1 -->
		<interceptors>
			<interceptor name="i1" class="com.interception.I1"></interceptor>
			<interceptor name="i2" class="com.interception.I2"></interceptor>
		</interceptors>	
		
		<action name="Customer_*" method="{1}_action" class="com.web.action.CustomerAction">
			<result name="{1}">/index.jsp</result>
			
			<!-- 拦截器的引用方法1，这里引入自定义拦截器后，
			必须手动引入默认拦截器defaultStack -->
			<interceptor-ref name="defaultStack"></interceptor-ref>
			<interceptor-ref name="i2"></interceptor-ref>
			<interceptor-ref name="i1"></interceptor-ref>
		</action>
	</package>	
	
	
	<package name="A" extends="struts-default" namespace="/">
	
		<!-- 拦截器的配置方法2 -->
		<interceptors>
			<interceptor name="i1" class="com.interception.I1"></interceptor>
			<interceptor name="i2" class="com.interception.I2"></interceptor>
			
			<interceptor-stack name="myStack">
				<interceptor-ref name="defaultStack"></interceptor-ref>
				<interceptor-ref name="i1"></interceptor-ref>
				<interceptor-ref name="i2"></interceptor-ref>
			</interceptor-stack>
		</interceptors>		


		<action name="a_*" class="com.action.A"  method="a{1}">
			<result name="login">/1.jsp</result>
			<result name="zhucefailed">/3.jsp</result>
			<result name="zhucesuccess">/3.jsp</result>			
			<result >/2.jsp</result>

			<!-- 拦截器的引用方法2-->
			<interceptor-ref name="myStack"></interceptor-ref>
		</action>	
	</package>
	
	
	<!--
	使用这个拦截器可以拦截部分方法，例如这里拦截a_*的所有方法，除了a1，a2方法（用来登陆）。
	也就是说没有登录的情况下，a_*的所有页面都打不开，包括不存在的页面，通过a1打开登陆ui，
	提交到a2登陆成功情况下session获得user，此时可以通过所有的拦截器。这种情况下似乎不能用第二种拦截器引用方法。
	public class I1 extends MethodFilterInterceptor {

	@Override
	protected String doIntercept(ActionInvocation arg0) throws Exception {
		Object user = ServletActionContext.getRequest().getSession().getAttribute("user");
		if (user == null) {
			ServletActionContext.getContext().put("result1", "FUCKYOU");
			return "login";
		} else {
			return arg0.invoke();
		}
	}-->
	<package name="A" extends="struts-default" namespace="/">
		<interceptors>
			<interceptor name="i1" class="com.interception.I1"></interceptor>
			<interceptor name="i2" class="com.interception.I2"></interceptor>			
		</interceptors>		


		<action name="a_*" class="com.action.A"  method="a{1}">
			<result  name="login">/1.jsp</result>
			<result name="zhucefailed">/WEB-INF/3.jsp</result>
			<result name="zhucesuccess">/WEB-INF/3.jsp</result>			
			<result name="index">/index.jsp</result>
			<result name="fff">/WEB-INF/2.jsp</result>
			<result type="redirectAction">a_f</result>

			<interceptor-ref name="i1">			
				<!--excludeMethods这个参数，只能用于继承MethodFilterInterceptor 类的拦截器上-->
				 <param name="excludeMethods">a1,a2</param>
			</interceptor-ref>
			<interceptor-ref name="i2"></interceptor-ref>
			<interceptor-ref name="defaultStack"></interceptor-ref>
		</action>	
	</package>
	
	<!--上面配置的都是局部拦截器，即每个action要用的拦截器在自己里面配置，
	全局拦截器可以使该package下所有action都使用此拦截器。	首先配置一个package，让它继承struts-default。然后配置自己的拦截器和global-results，因为这里会拦截下很多请求，需要处理。如果action没有配置局部拦截器，则走全局；如果配置了局部，就只走局部，不走全局。-->
	<package name="all" extends="struts-default">
        <interceptors>
            <!-- 自定义的拦截器 -->
            <interceptor name="mi" class="cn.me.MyInterceptor"></interceptor>
            <!-- 定义拦截器栈 -->
            <interceptor-stack name="ms">
                <!-- 默认拦截器 -->
                <interceptor-ref name="defaultStack"></interceptor-ref>
                <!-- 自定义拦截器 -->
                <interceptor-ref name="mi"></interceptor-ref>
            </interceptor-stack>
        </interceptors>
        <!-- 默认拦截器 -->
        <default-interceptor-ref name="ms"></default-interceptor-ref>
        <!-- 全局结果集 -->
        <global-results>
            <result name="login">/index.jsp</result>
        </global-results>
    </package>
	<!--接下来就就跟平常写配置文件没啥区别了，只是让其它包继承自我们自己的加了拦截器的包就可以了-->
	<package name="Struts" extends="all">
        <action name="Test" class="con.me.action.TestAction">
            <result name="success">/success.jsp</result>
            <result name="erroe">/error.jsp</result>
        </action>
    </package>


	
</struts>