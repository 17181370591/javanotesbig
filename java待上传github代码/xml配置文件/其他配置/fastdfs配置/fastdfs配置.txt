要导的包：

  	<dependency>
	    <groupId>org.csource.fastdfs</groupId>
	    <artifactId>fastdfs</artifactId>
	    <version>1.2</version>
	</dependency>
	<dependency>
		<groupId>commons-fileupload</groupId>
		<artifactId>commons-fileupload</artifactId>
	</dependency>
	
上传方法有两种：
	方法1：
	配置文件fdfs_client.conf内容：tracker_server=192.168.25.133:22122
	上传代码：
	
         // 1、加载配置文件，配置文件中的内容就是 tracker 服务的地址。
		ClientGlobal.init("D:/maven_work/fastDFS-demo/src/fdfs_client.conf");
		// 2、创建一个 TrackerClient 对象。直接 new 一个。
		TrackerClient trackerClient = new TrackerClient();
		// 3、使用 TrackerClient 对象创建连接，获得一个 TrackerServer 对象。
		TrackerServer trackerServer = trackerClient.getConnection();
		// 4、创建一个 StorageServer 的引用，值为 null
		StorageServer storageServer = null;
		// 5、创建一个 StorageClient 对象，需要两个参数 TrackerServer 对象、StorageServer 的引用
		StorageClient storageClient = new StorageClient(trackerServer, storageServer);
		
		// 6、使用 StorageClient 对象上传图片。
		//扩展名不带“.”
		String[] strings = storageClient.upload_file("D:/pic/benchi.jpg", "jpg",
				null);
		//上面是上传本地文件，也可以上传流，方法如下
		//byte[] b = new byte[1024 * 1024 * 5];
		//new FileInputStream(jpg).read(b);
		//String[] strings = storageClient.upload_file(b, "jpg", null);
		// String[] strings = storageClient.upload_file(jpg, "jpg", null);
		
		// 7、返回数组。包含组名和图片的路径。
		for (String string : strings) {
			System.out.println(string);
		}
	控制台输出如下结果：
	group1
	M00/00/00/wKgZhVkMP4KAZEy-AAA-tCf93Fo973.jpg
	在浏览器输入可以看到文件：
	http://192.168.25.133/group1/M00/00/00/wKgZhVkMP4KAZEy-AAA-tCf93Fo973.jpg
	
方法2：
	配置文件fdfs_client.conf内容：tracker_server=192.168.25.133:22122
	配置文件application.properties内容：FILE_SERVER_URL=http://192.168.25.133/
	上传代码(FILE_SERVER_URL相关可以全部删掉，然后写死)：

		@Value("${FILE_SERVER_URL}")
		private String FILE_SERVER_URL;//文件服务器地址
		
		@RequestMapping("/upload")
		public Result upload( MultipartFile file){				
			//1、取文件的扩展名
			String originalFilename = file.getOriginalFilename();
			String extName = originalFilename.substring(originalFilename.lastIndexOf(".") + 1);
			try {
				//2、创建一个 FastDFS 的客户端
				FastDFSClient fastDFSClient= new FastDFSClient("classpath:fdfs_client.conf");
				//3、执行上传处理
				String path = fastDFSClient.uploadFile(file.getBytes(), extName);
				//4、拼接返回的 url 和 ip 地址，拼装成完整的 url
				String url = FILE_SERVER_URL + path;			
				return new Result(true,url);			
			} catch (Exception e) {
				return new Result(false, "上传失败");
			}		
		}	
	

	
其他配置：

如果使用springMVC，需要在springmvc.xml添加配置：
	<!-- 配置多媒体解析器 -->
	<bean id="multipartResolver" class="org.springframework.web.multipart.commons.CommonsMultipartResolver">
			<property name="defaultEncoding" value="UTF-8"></property>
			<!-- 设定文件上传的最大值5MB，5*1024*1024 -->
			<property name="maxUploadSize" value="5242880"></property>
	</bean>
	
一般情况下springMVC前端和后端的代码参考 00-一些笔记\复习笔记\上传下载全局异常处理和ajax专题.txt

angularjs使用异步提交表单方法如下，没有测试，详情见 图片上传fastdfs.txt：
	app.service("uploadService",function($http){
		this.uploadFile=function(){
			var formData=new FormData();
			formData.append("file",file.files[0]);   
			return $http({
				method:'POST',
				url:"../upload.do",
				data: formData,
				headers: {'Content-Type':undefined},
				transformRequest: angular.identity
			});		
		}	
	});
anjularjs对于post和get请求默认的Content-Type header 是application/json。通过设置‘Content-Type’: undefined，这样浏览器会帮我们把Content-Type 设置为 multipart/form-data.

通过设置 transformRequest: angular.identity ，anjularjs transformRequest function 将序列化我们的formdata object.





	
如果使用struts2，见 
	<!-- struts.xml里添加下面这行：上传时文件稍大会报错，需要配置大小限制
	<constant name ="struts.multipart.maxSize" value ="100000000"/> -->